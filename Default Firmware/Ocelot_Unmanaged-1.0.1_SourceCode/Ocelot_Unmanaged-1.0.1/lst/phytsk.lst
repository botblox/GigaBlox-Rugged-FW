C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE PHYTSK
OBJECT MODULE PLACED IN ..\obj\phytsk.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\src\phy\phytsk.c LARGE OPTIMIZE(9,SIZE) INCDIR(c:\keil\c51\inc\winbon
                    -d;..\src\config;..\src\config\proj_opt;..\src\cli;..\src\main;..\src\switch;..\src\phy;..\src\util;..\src\switch\vtss_ap
                    -i\base;..\src\switch\vtss_api\base\ocelot;..\src\switch\include;..\src\lldp;..\src\snmp;..\src\sw_lacp;..\src\eee;..\src
                    -\eee\base\include;..\src\fan;..\src\led;..\src\loop) DEFINE(VTSS_ARCH_OCELOT,FERRET_F5,PROJ_OPT=0) DEBUG OBJECTEXTEND PR
                    -INT(..\lst\phytsk.lst) TABS(2) OBJECT(..\obj\phytsk.obj)

line level    source

   1          /*
   2          
   3           Copyright (c) 2017 Microsemi Corporation "Microsemi".
   4          
   5           Permission is hereby granted, free of charge, to any person obtaining a copy
   6           of this software and associated documentation files (the "Software"), to deal
   7           in the Software without restriction, including without limitation the rights
   8           to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   9           copies of the Software, and to permit persons to whom the Software is
  10           furnished to do so, subject to the following conditions:
  11          
  12           The above copyright notice and this permission notice shall be included in all
  13           copies or substantial portions of the Software.
  14          
  15           THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16           IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  17           FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  18           AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  19           LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  20           OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  21           SOFTWARE.
  22          
  23          */
  24          
  25          #include "common.h"     /* Always include common.h at the first place of user-defined herder files */
  26          #include "event.h"
  27          #include "vtss_api_base_regs.h"
  28          #include "vtss_common_os.h"
  29          #include "h2io.h"
  30          #include "h2.h"
  31          #include "phy_family.h"
  32          #include "phytsk.h"
  33          #include "phymap.h"
  34          #include "phydrv.h"
  35          #include "timer.h"
  36          #include "hwport.h"
  37          #include "h2gpios.h"
  38          #include "h2sdcfg.h"
  39          #include "h2pcs1g.h"
  40          #include "h2txrx.h"
  41          #if FRONT_LED_PRESENT
  42          #include "ledtsk.h"
  43          #endif
  44          #include "misc1.h"
  45          #include "misc2.h"
  46          #if TRANSIT_LLDP
              #include "lldp.h"
              #endif /* TRANSIT_LLDP */
  49          #if TRANSIT_VERIPHY
              #include "veriphy.h"
              #endif
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 2   

  52          #if USE_HW_TWI
  53          #include "i2c_h.h"
  54          #endif
  55          #if USE_SW_TWI
              #include "i2c.h"
              #endif
  58          
  59          #if defined(PHYTSK_DEBUG_ENABLE)
  60          #include "print.h"
  61          #endif /* PHYTSK_DEBUG_ENABLE */
  62          
  63          #if TRANSIT_LACP
              #include "vtss_lacp.h"
              #endif /* TRANSIT_LACP */
  66          
  67          /*****************************************************************************
  68           *
  69           *
  70           * Defines
  71           *
  72           *
  73           *
  74           ****************************************************************************/
  75          
  76          /* define states of state machine */
  77          #define PORT_DISABLED                   0
  78          #define PHY_SET_UP_SPEED_MODE           1
  79          #define PHY_WAITING_FOR_LINK            2
  80          #define PHY_LINK_UP                     3
  81          #define SERDES_SIG_SET_UP_MODE         99   // Used for serdes initial state
  82          #define SERDES_SET_UP_MODE            100
  83          #define SERDES_WAITING_FOR_LINK       101
  84          #define SERDES_LINK_UP                102
  85          
  86          /* define periods in granularity of 10 msec */
  87          #define POLL_PERIOD_FOR_LINK           10 /* 100 msec */
  88          
  89          #define MAX_THERMAL_PROT_TIME 10 /* 10 sec */
  90          #define MAX_JUNCTION_TEMP 122
  91          
  92          
  93          /* The SFP port link mode is unstable when two Ferret boards are connected.
  94           * Make a workaround to confirm the link mode again.
  95           */
  96          #define FERRET_SFP_LM_WORKAROUND
  97          
  98          /*****************************************************************************
  99           *
 100           *
 101           * Typedefs and enums
 102           *
 103           *
 104           *
 105           ****************************************************************************/
 106          
 107          /*****************************************************************************
 108           *
 109           *
 110           * Prototypes for local functions
 111           *
 112           *
 113           *
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 3   

 114           ****************************************************************************/
 115          
 116          /*****************************************************************************
 117           *
 118           *
 119           * Local data
 120           *
 121           *
 122           *
 123           ****************************************************************************/
 124          
 125          /* Link-up status chip port mask */
 126          static port_bit_mask_t linkup_cport_mask = 0;
 127          
 128          /* Port link mode */
 129          static uchar xdata port_lm[NO_OF_CHIP_PORTS];
 130          
 131          /* Port state machine */
 132          static uchar xdata port_state_machine[NO_OF_CHIP_PORTS];
 133          
 134          /* Port MAC media interface */
 135          #if MAC_TO_MEDIA
 136          static uchar xdata mac_if_changed[NO_OF_CHIP_PORTS];
 137          #endif // MAC_TO_MEDIA
 138          
 139          /* Config Flow control mode of each PHY/Serdes port */
 140          #if defined(UNMANAGED_FLOW_CTRL_IF)
 141          static uchar xdata port_fc_config[NO_OF_CHIP_PORTS];
 142          #endif // UNMANAGED_FLOW_CTRL_IF
 143          
 144          /* Flag for activate polling of PHYs */
 145          static bit poll_phy_flag = 0;
 146          
 147          #if TRANSIT_THERMAL
              /* Flag for activate polling of PHYs temperature monitor */
              static BOOL start_thermal_protect_timer = FALSE;
              static ushort thermal_protect_cnt = 0;
              static port_bit_mask_t led_err_stat = 0;
              #endif // TRANSIT_THERMAL
 153          
 154          /* Let all PHYs initially be powered down/disabled */
 155          static port_bit_mask_t phy_enabled = ALL_PORTS;
 156          
 157          #if TRANSIT_THERMAL
              static uchar max_protect_temp = MAX_JUNCTION_TEMP;
              #endif
 160          
 161          #define POLARITY_DETECT_FOR_10HDX_MODE
 162          
 163          
 164          /****************************************************************************
 165           *
 166           * Local functions
 167           *
 168           ****************************************************************************/
 169          
 170          /**
 171           * Initialize all PHYs after a power up reset.
 172           */
 173          static void phy_init (void)
 174          {
 175   1          vtss_iport_no_t iport_idx;
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 4   

 176   1          vtss_cport_no_t chip_port;
 177   1          u16 reg_val;
 178   1      
 179   1          delay(MSEC_30);
 180   1      
 181   1      #if defined(LUTON26_L25)
                  phy_pre_reset(0);
                  phy_pre_reset(12);
                  if (phy_map(25)) { //using MDC/MDIO
                      phy_pre_reset(25); /*L25, port25 uses external single */
                  }
              
              #elif defined(LUTON26_L16)
                  phy_pre_reset(0);
              #ifdef LUTON26_L16_QSGMII_EXT_PHY
                  phy_pre_reset(12);
              #endif /* LUTON26_L16_QSGMII_EXT_PHY */
              
              #elif defined(LUTON26_L10)
                  phy_pre_reset(0);
                  if (phy_map(24)) {//using MDC/MDIO
                      phy_pre_reset(24); /* L10, port24 uses external single  PHY */
                  }
                  if (phy_map(25)) {//using MDC/MDIO
                      phy_pre_reset(25); /* L10, port25 uses external single PHY*/
                  }
              #endif // LUTON26_L25
 203   1      
 204   1      
 205   1      #if defined(LUTON26_L25)
                  phy_page_std(12);
              #endif
 208   1      
 209   1      #if defined(FERRET_F11) || defined(FERRET_F10P)|| defined(FERRET_F5) || defined(FERRET_F4P)
 210   1          // Reset PHY when using multiple PHY types
 211   1          phy_pre_reset(0);
 212   1      
 213   1      #if defined(FERRET_F11) || defined(FERRET_F10P)
                  phy_pre_reset(4);
              #endif // FERRET_F11 || FERRET_F10P
 216   1      
 217   1      #if defined(NPI_CHIP_PORT) && NPI_CHIP_PORT != NPI_ACT_NORMAL_PORT
              #if defined(FERRET_F11)
                  phy_pre_reset(NPI_CHIP_PORT);
              #endif // FERRET_F11
                  {
                      h2_npi_conf_t npi_conf;
              
                      /* Here's just a sample of NPI port configuraiton
                       * Choice the suitable prefix mdoe and queues as the default setting.
                       */
                      npi_conf.chip_port = NPI_CHIP_PORT;
                      npi_conf.mode_enabled = TRUE;
                      npi_conf.queue_mask = 0xFF & (~(1 << PACKET_XTR_QU_BPDU_LLDP));
                      npi_conf.prefix_header_mode = H2_PREFIX_HEADER_MODE_LONG;
                      npi_port_set(&npi_conf);
                  }
              #endif // NPI_CHIP_PORT && NPI_CHIP_PORT != NPI_ACT_NORMAL_PORT
 234   1      
 235   1      #endif // FERRET_F11 || FERRET_F10P|| FERRET_F5 || FERRET_F4P
 236   1      
 237   1          delay(MSEC_2000); // delay_1(2000);
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 5   

 238   1          phy_page_std(0);
 239   1          reg_val = 0;
 240   1      
 241   1          for (iport_idx = MIN_PORT; iport_idx < MAX_PORT; iport_idx++) {
 242   2              chip_port = iport2cport(iport_idx);
 243   2      
 244   2              if (phy_map(chip_port)) {
 245   3                  if (TEST_PORT_BIT_MASK(chip_port, &phy_enabled)) {
 246   4      #if defined(FERRET_F11) || defined(FERRET_F10P)|| defined(FERRET_F5) || defined(FERRET_F4P)
 247   4                      if(iport_idx >= MIN_PORT && iport_idx <= MIN_PORT+3) {
 248   5                          /* Work around for Bz#21484 ,applicable for MINI
 249   5                           * Default =0; Address 0x07f8;  Field is 2-bits wide: 4:3; So it will be Modifications
             - in the Lower 16 bits, ie. TR_17 and nothing in TR_18,  TR_16=0x87f8 for a Write to addr: 0x07f8*/
 250   5      
 251   5                          phy_page_tr(chip_port);
 252   5                          phy_write(chip_port,16,0xa7f8);
 253   5                          reg_val = phy_read(chip_port,17);
 254   5                          reg_val &= 0xffe7;
 255   5                          reg_val |= 3<<3;
 256   5                          phy_write(chip_port,17,reg_val);
 257   5                          phy_write(chip_port,16,0x87f8);
 258   5                          /* Work around for Bz#21485 ,applicable for MINI
 259   5                           * Default =19; Address 0x0fa4;  Field is 7-bits wide: 22:16; So it will be Modificati
             -ons in the Upper 16 bits, ie. TR_18 and nothing in TR_17,  TR_16=0x8fa4 for a Write to addr: 0x0fa4
 260   5                           * VgaThresh100=24 from default  value 19*/
 261   5                          phy_write(chip_port,16,0xafa4);
 262   5                          reg_val = phy_read(chip_port,18);
 263   5                          reg_val &= 0xff80;
 264   5                          reg_val |= 24;
 265   5                          phy_write(chip_port,18,reg_val);
 266   5                          phy_write(chip_port,16,0x8fa4);
 267   5                          phy_page_std(chip_port);
 268   5                      }
 269   4      #endif
 270   4                      phy_setup(chip_port);
 271   4                      phy_post_reset(chip_port);
 272   4                  } else {
 273   4      #if defined(PHYTSK_DEBUG_ENABLE)
 274   4                      print_str("port in power down state chip_port = ");
 275   4                      print_dec(chip_port);
 276   4                      print_cr_lf();
 277   4      #endif /* PHYTSK_DEBUG_ENABLE */
 278   4                      phy_power_down(chip_port);
 279   4                  }
 280   3              }
 281   2          }
 282   1      
 283   1      #if VTSS_COBRA && defined(FERRET_F11)
                  cobra_power_saving_disable(9);
              #endif
 286   1      
 287   1      #if TRANSIT_FAN_CONTROL || TRANSIT_THERMAL
                  phy_init_temp_mode_regs(0);
              #endif // TRANSIT_FAN_CONTROL || TRANSIT_THERMAL
 290   1      
 291   1      #if defined(LUTON26_L25)
              #if TRANSIT_FAN_CONTROL || TRANSIT_THERMAL
                  phy_init_temp_mode_regs(12);
              #endif // TRANSIT_FAN_CONTROL || TRANSIT_THERMAL
              #endif
 296   1      }
 297          
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 6   

 298          static void _sfp_tx_disable_set(vtss_cport_no_t chip_port, BOOL is_disable)
 299          {
 300   1      #if defined(LUTON26_L25)
                  chip_port = chip_port; // Quiet Keil compile warning
                  h2_gpio_write(GPIO_SFP_TXDISABLE, is_disable);   // Enable SFP TX
              
              #elif defined(FERRET_F11) || defined(FERRET_F10P)
                  if (chip_port == SFP1_CHIP_PORT) {   // SFP1
                      h2_gpio_write(GPIO_SFP1_TXDISABLE, is_disable);  // Enable SFP TX
                  } else if (chip_port == SFP2_CHIP_PORT) { // SFP2
                      h2_gpio_write(GPIO_SFP2_TXDISABLE, is_disable);  // Enable SFP TX
                  }
              
              #elif defined(FERRET_F5)
 312   1          if (chip_port == SFP2_CHIP_PORT) { // SFP2
 313   2              h2_gpio_write(GPIO_SFP2_TXDISABLE, is_disable);  // Enable SFP TX
 314   2          }
 315   1      
 316   1      #else
                  // Quiet Keil compile warning
                  chip_port = chip_port;
                  is_disable = is_disable;
              #endif
 321   1      }
 322          
 323          /**
 324           * Initialize all SFP gpio controls after a power up reset.
 325           */
 326          static void sfp_init (void)
 327          {
 328   1      #if defined(LUTON26_L25)
                  phy_page_std(SFP_MODULE_GPIO_PORT);
              
                  /* Configure  PHY GPIO 2, 3 as input, and 4 as output */
                  phy_page_gp(SFP_MODULE_GPIO_PORT);
              
                  /* Step 1. setup GPIO 2, 3, 4 is controled by GPIO function */
                  phy_write_masked(SFP_MODULE_GPIO_PORT, 13, 0x00fc, 0x00fc);
              
                  /* Step 2, setup input and output pins */
                  phy_write_masked(SFP_MODULE_GPIO_PORT, 17, 0x0010, 0x001c);
                  phy_page_std(SFP_MODULE_GPIO_PORT);
              
                  /* Use normal GPIO function */
                  h2_gpio_mode_set(GPIO_SFP_TXDISABLE, VTSS_GPIO_OUT);
                  h2_gpio_write(GPIO_SFP_TXDISABLE, TRUE);    // Disable SFP TX
              
              #elif defined(LUTON26_L10)
                  h2_sgpio_write(30, 0, 0); // Set tx_enable
                  h2_sgpio_write(31, 0, 0); // Set tx_enable
              
              #elif defined(LUTON26_L16) && defined(LUTON26_L16_QSGMII_EXT_PHY)
                  h2_gpio_mode_set(GPIO_SFP_TXDISABLE, VTSS_GPIO_OUT);
                  h2_gpio_write(GPIO_SFP_TXDISABLE, FALSE);   // Enable SFP TX
                  h2_gpio_write(GPIO_SFP_TXDISABLE, TRUE);    // Disable SFP TX
              
              #elif defined(FERRET_F11) || defined(FERRET_F10P)
                  /* BZ#21826 - Drive SFP ports rate select (GPIO 18/19) to high */
                  h2_gpio_mode_set(GPIO_SFP1_RATESEL, VTSS_GPIO_OUT);
                  h2_gpio_write(GPIO_SFP1_RATESEL, TRUE);
                  h2_gpio_mode_set(GPIO_SFP2_RATESEL, VTSS_GPIO_OUT);
                  h2_gpio_write(GPIO_SFP2_RATESEL, TRUE);
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 7   

              
                  /* Set SFP_TXDISABLE GPIO pins as the output mode first,
                   * and then disable TX feature in the initial state.
                   * It will be enabled when the SFP module present.
                   * See phytsk.c/handle_serdes()/case SERDES_SET_UP_MODE
                   */
                  // SFP1
                  h2_gpio_mode_set(GPIO_SFP1_TXDISABLE, VTSS_GPIO_OUT);
                  _sfp_tx_disable_set(SFP1_CHIP_PORT, TRUE);   // Disable SFP TX
              
                  // SFP2
                  h2_gpio_mode_set(GPIO_SFP2_TXDISABLE, VTSS_GPIO_OUT);
                  _sfp_tx_disable_set(SFP2_CHIP_PORT, TRUE);  // Disable SFP TX
              
              #elif defined(FERRET_F5)
 375   1          // SFP2
 376   1          /* BZ#21826 - Drive SFP ports rate select (GPIO 19) to high */
 377   1          h2_gpio_mode_set(GPIO_SFP2_RATESEL, VTSS_GPIO_OUT);
 378   1          h2_gpio_write(GPIO_SFP2_RATESEL, TRUE);
 379   1      
 380   1          h2_gpio_mode_set(GPIO_SFP2_TXDISABLE, VTSS_GPIO_OUT);
 381   1          _sfp_tx_disable_set(SFP2_CHIP_PORT, TRUE);  // Disable SFP TX
 382   1      
 383   1      #endif
 384   1      }
 385          
 386          static uchar phy_init_state (vtss_cport_no_t chip_port)
 387          {
 388   1          if (phy_map(chip_port)) {
 389   2              if (TEST_PORT_BIT_MASK(chip_port, &phy_enabled)) {
 390   3                  phy_write_masked(chip_port, 18, 0x0040, 0x0040);
 391   3                  return PHY_SET_UP_SPEED_MODE;
 392   3              } else {
 393   3                  return PORT_DISABLED;
 394   3              }
 395   2          }
 396   1      #if MAC_TO_MEDIA
 397   1          else if (phy_map_serdes(chip_port)) {
 398   2              return SERDES_SIG_SET_UP_MODE;
 399   2          }
 400   1      #endif
 401   1          else {
 402   2              return PORT_DISABLED;
 403   2          }
 404   1      }
 405          
 406          /*
 407          ** Return link mode
 408          ** bit 1:0 = 00:   No link
 409          ** bit 1:0 = 01: 1000 Mbit/s
 410          ** bit 1:0 = 10:  100 Mbit/s
 411          ** bit 1:0 = 11:   10 Mbit/s
 412          **
 413          ** bit 4 = 0: half duplex
 414          ** bit 4 = 1: full duplex
 415          **
 416          ** bit 5 = 0: link partner doesn't support pause frames
 417          ** bit 5 = 1: link partner does support pause frames
 418          
 419          ** bit 7:6 = 00: No EEE advertised
 420          ** bit 7:6 = 01: 100Base EEE advertised
 421          ** bit 7:6 = 10: 1000Base EEE advertised
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 8   

 422          ** bit 7:6 = 11: Reserved
 423          */
 424          /* Fixme: Tune the two functions to fit VSC8522/12 */
 425          static uchar phy_link_mode_get(vtss_cport_no_t chip_port)
 426          {
 427   1          int eee_advertisement;
 428   1          uchar link_mode = LINK_MODE_DOWN;
 429   1      
 430   1          if (phy_link_status(chip_port)) {
 431   2              link_mode = phy_get_speed_and_fdx(chip_port);
 432   2      
 433   2              /* check if link partner supports pause frames */
 434   2              if (phy_read(chip_port, 5) & 0x0400) {
 435   3                  link_mode |= LINK_MODE_PAUSE_MASK;
 436   3              }
 437   2      
 438   2              // 802.3az says EEE is supported only under full-duplex mode
 439   2              if (!(link_mode & LINK_MODE_FDX_MASK))
 440   2                  return link_mode;
 441   2      
 442   2              // Get EEE advertisement
 443   2              eee_advertisement = phy_mmd_rd(chip_port, 7, 61);// 7.61 EEE Link Partner Advertisement.
 444   2      
 445   2              //Table 96, in data sheet
 446   2              if (eee_advertisement & 0x2) {
 447   3                  link_mode |= LINK_MODE_POWER_MASK_100BASE;
 448   3              } else if (eee_advertisement & 0x4) {
 449   3                  link_mode |= LINK_MODE_POWER_MASK_1000BASE;
 450   3              }
 451   2          }
 452   1      
 453   1          return link_mode;
 454   1      }
 455          
 456          #if MAC_TO_MEDIA
 457          static uchar serdes_link_mode_get(vtss_cport_no_t chip_port)
 458          {
 459   1          uchar mac_if;
 460   1          uchar lm = LINK_MODE_DOWN;
 461   1      
 462   1          if (phy_map_serdes(chip_port)) {
 463   2              mac_if = phy_map_miim_no(chip_port);
 464   2              if (mac_if == MAC_IF_SERDES_1G || mac_if == MAC_IF_SGMII) {
 465   3      #ifdef SGMII_SERDES_FORCE_1G_DEBUG_ENABLE
                          lm = h2_pcs1g_status_get(chip_port);
              #else
 468   3                  lm = h2_pcs1g_clause_37_status_get(chip_port);
 469   3      #endif
 470   3              } else if (mac_if == MAC_IF_100FX) {
 471   3                  lm = h2_pcs1g_100fx_status_get(chip_port);
 472   3              } else if (mac_if == MAC_IF_SERDES_2_5G) {
 473   3                  lm = h2_pcs1g_2_5g_link_status_get(chip_port);
 474   3              }
 475   2      
 476   2      #if defined(FERRET_SFP_LM_WORKAROUND) && !defined(SGMII_SERDES_FORCE_1G_DEBUG_ENABLE)
 477   2              // Double Confirm
 478   2              delay_1(2);
 479   2              if (((mac_if == MAC_IF_SERDES_1G || mac_if == MAC_IF_SGMII) && lm != h2_pcs1g_clause_37_status_get
             -(chip_port)) ||
 480   2                  (mac_if == MAC_IF_100FX && lm != h2_pcs1g_100fx_status_get(chip_port)) ||
 481   2                  (mac_if == MAC_IF_SERDES_2_5G && lm != h2_pcs1g_2_5g_link_status_get(chip_port))) {
 482   3                  lm = port_lm[chip_port]; // Keep the original link mode
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 9   

 483   3              }
 484   2      #endif // FERRET_SFP_LM_WORKAROUND
 485   2          }
 486   1      
 487   1          return lm;
 488   1      }
 489          #endif // MAC_TO_MEDIA
 490          
 491          static void do_link_up(vtss_cport_no_t chip_port, char link_mode)
 492          {
 493   1          WRITE_PORT_BIT_MASK(chip_port, 1, &linkup_cport_mask);
 494   1      
 495   1          VTSS_UPDATE_MASKS_DEBUG();
 496   1          vtss_update_masks();
 497   1          port_lm[chip_port] = link_mode;
 498   1          /* Work around for Bz #21483 */
 499   1          (void)phy_read(chip_port,10);
 500   1          callback_link_up(chip_port);
 501   1      }
 502          
 503          static void do_link_down(vtss_cport_no_t chip_port)
 504          {
 505   1          WRITE_PORT_BIT_MASK(chip_port, 0, &linkup_cport_mask);
 506   1      
 507   1          if (phy_map(chip_port)) {
 508   2              /* Do any set-up of PHY due to link going down */
 509   2              phy_do_link_down_settings(chip_port);
 510   2          }
 511   1      
 512   1          h2_setup_port(chip_port, LINK_MODE_DOWN);
 513   1          port_lm[chip_port] = LINK_MODE_DOWN;
 514   1          callback_link_down(chip_port);
 515   1      }
 516          
 517          BOOL phy_flowcontrol_get(vtss_cport_no_t chip_port)
 518          {
 519   1      #if defined(TRANSIT_LACP) && defined(TRANSIT_LACP_FC_OP) // Disalbe FC on LACP-enabled port
                  portno = cport2uport(chip_port);
                  vtss_lacp_get_portconfig(portno, &cfg);
              
              #if defined(PHYTSK_DEBUG_ENABLE)
                  print_str("chip_port: "); print_dec(chip_port);
                  print_str("u_port: "); print_dec(portno); print_cr_lf();
              #endif //PHYTSK_DEBUG_ENABLE
              
                  if (cfg.enable_lacp == TRUE) {
                      // disable flow control to avoid LACP packets stopping by pause
                      //frames, which causes LACP not working
                      return FALSE;
                  } else {
                      return TRUE;
                  }
                  return TRANSIT_FLOW_CTRL_DEFAULT;
              
              #elif defined(UNMANAGED_FLOW_CTRL_IF)
 538   1          return port_fc_config[chip_port];
 539   1      
 540   1      #else // The same as default
                  chip_port = chip_port;  // quiet compiler
                  return TRANSIT_FLOW_CTRL_DEFAULT;
              #endif // TRANSIT_LACP
 544   1      }
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 10  

 545          
 546          /**
 547           * State machine for copper phy. Monitor PHY and set up H2 port.
 548           */
 549          static void handle_phy (vtss_cport_no_t chip_port)
 550          {
 551   1          uchar  link_mode;
 552   1          ushort phy_data;
 553   1      
 554   1      
 555   1          switch (port_state_machine[chip_port]) {
 556   2          case PORT_DISABLED: {
 557   3              break;
 558   3          }
 559   2      
 560   2          case PHY_SET_UP_SPEED_MODE: {
 561   3              /* Update register 4 with 10/100 advertising, plus pause capability */
 562   3      
 563   3          if (phy_flowcontrol_get(chip_port) != TRUE) {
 564   4              // disable flow control to avoid LACP packets stopping by pause
 565   4              //frames, which causes LACP not working
 566   4              phy_data = 0x01e1;
 567   4              phy_write(chip_port, 4, phy_data);
 568   4          } else {
 569   4              phy_data = 0x05e1;
 570   4              phy_write(chip_port, 4, phy_data);
 571   4          }
 572   3      
 573   3      #if defined(PHYTSK_DEBUG_ENABLE)
 574   3              if (phy_read(chip_port, 4) != phy_data) {
 575   4                  print_str("%% Flow control setting failed on uport ");
 576   4                  print_dec_8_right_2(cport2uport(chip_port));
 577   4                  print_cr_lf();
 578   4              }
 579   3      #endif /* PHYTSK_DEBUG_ENABLE */
 580   3      
 581   3              /*  Update register 9 with 1000 Mbps advertising */
 582   3              phy_write(chip_port, 9, PHY_REG_9_CONFIG);
 583   3              /* Restart auto-negotiation */
 584   3              phy_restart_aneg(chip_port);
 585   3      
 586   3              port_state_machine[chip_port] = PHY_WAITING_FOR_LINK;    // Change state
 587   3              break;
 588   3          }
 589   2      
 590   2          case PHY_WAITING_FOR_LINK: {
 591   3              if (!poll_phy_flag) {
 592   4                  return;
 593   4              }
 594   3      
 595   3              /* Check if link is up */
 596   3              link_mode = phy_link_mode_get(chip_port);
 597   3              if (link_mode != LINK_MODE_DOWN) { // Link-up
 598   4      #if defined(PHYTSK_DEBUG_ENABLE)
 599   4                  uchar speed = link_mode & LINK_MODE_SPEED_MASK;
 600   4      
 601   4                  print_str("PHY Link-Up on uport");
 602   4                  print_dec_8_right_2(cport2uport(chip_port));
 603   4                  if (speed == LINK_MODE_SPEED_10) {
 604   5                      print_str(" - 10M");
 605   5                  } else if (speed == LINK_MODE_SPEED_100) {
 606   5                      print_str(" - 100M");
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 11  

 607   5                  } else if (speed == LINK_MODE_SPEED_1000) {
 608   5                      print_str(" - 1G");
 609   5                  } else if (speed == LINK_MODE_SPEED_2500) {
 610   5                      print_str(" - 2.5G");
 611   5                  } else {
 612   5                      print_str("Unknown speed");
 613   5                  }
 614   4                  if (link_mode & LINK_MODE_FDX_MASK) {
 615   5                      println_str("FDX");
 616   5                  } else {
 617   5                      println_str("HDX");
 618   5                  }
 619   4      #endif /* PHYTSK_DEBUG_ENABLE */
 620   4      
 621   4                  /* Update switch chip according to link */
 622   4                  h2_setup_port(chip_port, link_mode);
 623   4      
 624   4                  /* Do any set-up of PHY due to link going up */
 625   4                  phy_do_link_up_settings(chip_port, link_mode, 0);
 626   4      
 627   4                  do_link_up(chip_port, link_mode);
 628   4      
 629   4      #ifdef POLARITY_DETECT_FOR_10HDX_MODE
 630   4                  if ((link_mode & (LINK_MODE_SPEED_MASK | LINK_MODE_FDX_MASK)) == LINK_MODE_HDX_10) {//10HDX
 631   5                      //println_str("Link is up: checking polarit...");
 632   5                      phy_data = phy_read(chip_port, 28);
 633   5                      if (phy_data&0x0C00) { //if POL_INVERSE bits[11:10] is set : polarity swapped
 634   6                          phy_write(chip_port, 31, 0x2a30);  // switch to test-register page
 635   6                          phy_write_masked(chip_port, 5, 0x6, 0x6);    // write[2:1]={11}: force inversion
 636   6                          phy_write(chip_port, 31, 0x0);    // switch to std page
 637   6                      } else { //bit[11:10] is clear
 638   6                          phy_write(chip_port, 31, 0x2a30);  // switch to test-register page
 639   6                          phy_write_masked(chip_port, 5, 0x4, 0x6);    // write[2:1]={10}: force normal polarity
 640   6                          phy_write(chip_port, 31, 0x0);   // switch to std page
 641   6                      }
 642   5      
 643   5                      /* disable polarity detection */
 644   5                      phy_write_masked(chip_port, 0x12, 0x0010, 0x0010);
 645   5                  }
 646   4      #endif //POLARITY_DETECT_FOR_10HDX_MODE
 647   4      
 648   4                  port_state_machine[chip_port] = PHY_LINK_UP; // Change state
 649   4              }
 650   3              break;
 651   3          }
 652   2      
 653   2          case PHY_LINK_UP: {
 654   3              if (poll_phy_flag) {
 655   4                  /* Check if link has been down or link mode is changed */
 656   4                  link_mode = phy_link_mode_get(chip_port);
 657   4      
 658   4                  if (link_mode == LINK_MODE_DOWN || link_mode != port_lm[chip_port]) {
 659   5                      do_link_down(chip_port);
 660   5      #ifdef POLARITY_DETECT_FOR_10HDX_MODE
 661   5      #if defined(PHYTSK_DEBUG_ENABLE)
 662   5                      print_str("PHY Link-Down on uport");
 663   5                      print_dec_8_right_2(cport2uport(chip_port));
 664   5                      print_cr_lf();
 665   5      #endif /* PHYTSK_DEBUG_ENABLE */
 666   5                      phy_write(chip_port, 31, 0x2a30);  // switch to test-register page
 667   5                      phy_write_masked(chip_port, 5, 0x0, 0x6);    // write[2:1]={00}:Unforce polarity
 668   5                      phy_write(chip_port, 31, 0x0); // switch to std page
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 12  

 669   5      
 670   5                      /* enable polarity detection */
 671   5                      phy_write_masked(chip_port, 0x12, 0x0000, 0x0010);
 672   5      #endif // POLARITY_DETECT_FOR_10HDX_MODE
 673   5      
 674   5                      port_state_machine[chip_port] = PHY_WAITING_FOR_LINK;    // Change state
 675   5                 }
 676   4              }
 677   3              break;
 678   3          }
 679   2      
 680   2          default:
 681   2              break;
 682   2          }
 683   1      }
 684          
 685          #if  MAC_TO_MEDIA
 686          #define SFP_SONET_COMPLIANCE_CODE               0x04    // SONET Compliance Codes
 687          /* byte     Bit     Ethernet Compliance Codes
 688           *    4       5     OC-192, short reach2 8 3 Active Cable 8
 689           *    4       4     SONET reach specifier bit 1 8 2 Passive Cable 8
 690           *    4       3     SONET reach specifier bit 2 Unallocated
 691           *    4       2     OC-48, long reach 2 8 1 Unallocated
 692           *    4       1     OC-48, intermediate reach
 693           *    5       7     Unallocated
 694           *    5       6     OC-12, single mode, long reach
 695           *    5       5     OC-12, single mode, inter. reach
 696           *    5       4     OC-12, short reach
 697           *    5       3     Unallocated
 698           *    5       2     OC-3, single mode, long reach
 699           *    5       1     OC-3, single mode, inter. reach
 700           *    5       0     OC-3, short reach
 701           */
 702          #define SFP_ETHERNET_COMPLIANCE_CODE            0x06    // Ethernet Compliance Codes
 703          
 704          /* byte     Bit     Fiber Channel Transmission Media
 705           *    9       7     Twin Axial Pair (TW)
 706           *    9       6     Twisted Pair (TP)
 707           *    9       5     Miniature Coax (MI)
 708           *    9       4     Video Coax (TV)
 709           *    9       3     Multimode, 62.5um (M6)
 710           *    9       2     Multimode, 50um (M5, M5E)
 711           *    9       1     Unallocated
 712           *    9       0     Single Mode (SM)
 713           */
 714          #define SFP_FIBER_CHANNEL_TRANSMISSION_CODE     0x09    // Fiber Channel Transmission Media
 715          
 716          
 717          #if TRANSIT_SFP_DETECT
 718          #if USE_SW_TWI
              static uchar i2c_read(uchar addr, uchar reg)
              {
                  uchar ack;
                  uchar temp;
              
                  i2c_start();
                  ack = i2c_send_byte(addr << 1);
                  ack = i2c_send_byte(reg & 0xff);
              
                  i2c_start();
                  ack = i2c_send_byte((addr << 1) | 1);
              
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 13  

                  /* read LS byte */
                  temp = i2c_get_byte(0);
              
                  i2c_stop();
              
                  return temp;
              }
              #endif /* USE_SW_TWI */
 739          
 740          /* Enable I2C access and perform a read */
 741          static uchar sfp_i2c_read(uchar dev, vtss_port_no_t port_no, uchar addr, uchar *const value, uchar cnt)
 742          {
 743   1          uchar ret;
 744   1          uchar i2c_scl_gpio;
 745   1      #if USE_SW_TWI
                  uchar c;
              #endif
 748   1          if (!phy_map_serdes(port_no))
 749   1              return 0;
 750   1      #if USE_HW_TWI
 751   1          i2c_scl_gpio = phy_map_phy_no(port_no);
 752   1          i2c_tx(i2c_scl_gpio, dev, &addr, 1);
 753   1          //delay(MSEC_20);
 754   1          ret = i2c_rx(i2c_scl_gpio, dev, value, cnt);
 755   1      #endif
 756   1      #if USE_SW_TWI
                  ret = 0;
                  for (c = 0; c < cnt; c++) {
                      *(value + c) = i2c_read(dev, (addr+c));
                      if (*(value + c) != 0xff) ret |= 1;
                  }
              #if 0
                  for (c = 0; c < cnt; c++) {
                      print_hex_b(*(value + c));
                      print_ch(' ');
                  }
                  print_str(", ret = ");
                  print_dec(ret);
                  print_cr_lf();
              #endif
              #endif
 772   1          return ret;
 773   1      }
 774          
 775          #if defined(FERRET_F11) || defined(FERRET_F10P) || defined(FERRET_F5) || defined(FERRET_F4P)
 776          // No support copper SFP modules in Ferret
 777          #define CuSFP_DET   0
 778          #else
              #define CuSFP_DET   0 /* 1 */    /* Not implemented yet */
              #endif
 781          
 782          // Read SFP EEPROM information(MSA) via I2C bus
 783          static uchar sfp_detect(vtss_cport_no_t chip_port)
 784          {
 785   1      #if TRANSIT_LLDP || LOOPBACK_TEST
                  uchar *buf = &rx_packet[0];
              #else
 788   1          uchar buf[30];
 789   1      #endif
 790   1      
 791   1      #if CuSFP_DET
              {
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 14  

                  ulong vendor;
                  const char *CuSFPModel[2] = { "AXGT-R1T", "AXGT-R15" };
              
                  /* I2C slave address 0x50 is the SFP EEPORM address and 0x56 is the SFP copper phy */
                  if (sfp_i2c_read(0x50, chip_port, 12, &buf[0], 1)) {//MSA EERPOM byte[12], rate in unit of 100Mbits/s
                      //print_str("sfp rate:");
                      //print_dec(buf[0]);   print_cr_lf();
                      if (buf[0] >= 1 && buf[0] <= 2) {        /* 100Mb capabilities --> 100FX */
                          return MAC_IF_100FX;
                      } else if (buf[0] >= 25) { /* 2500Mb capabilities */
                          //print_str(">2.5G SFP");
                          //print_cr_lf();
                          return MAC_IF_SERDES_2_5G; /* Currently default for 2.5G operation */
                      }
                      else if (buf[0] >= 10 && buf[0] <= 22) { /* 1Gb capabilities -->  Copper SFP or Serdes 1000Base-X 
             -*/
                          if (sfp_i2c_read(0x50, chip_port, 40, &buf[0], 8)) {   /* Try to recognize the SFP module via 
             -EEPROM */
                              buf[8] = '\0';
                              if (xmemcmp((char *)CuSFPModel[0],(char*)buf, 8) == 0) {        /* Axcen SFP_CU_SGMII */
                                  return MAC_IF_SGMII;
                              } else if (xmemcmp((char *)CuSFPModel[1], (char*)buf, 8) == 0) { /* Axcen SFP_CU_SERDES */
                                  return MAC_IF_SERDES_1G;
                              }
                          }
              
                          /* Vender is unknown, then read PHY registers */
                          /* Try to determine the SFP host mode (serdes/sgmii) via the Phy settings */
                          if (sfp_i2c_read(0x56, chip_port, 0, &buf[0], 8)) {
                              /* The Phy is there, find the vendor id and if the phy is in SGMII or Serdes mode */
                              vendor = (((buf[4] << 8) | buf[5]) << 6) | ((((buf[6] << 8) | buf[7]) >> 10) & 0x3f);
                              if (vendor == 0x3f1) { /* VTSS phy in SERDES mode */
                                  return MAC_IF_SERDES_1G;
                              } else if (vendor == 0x5043) { /* Marvell phy */
                                  if (sfp_i2c_read(0x56, chip_port, 0, &buf[0], 22) &&
                                          sfp_i2c_read(0x56, chip_port, 22, &buf[0], 22)) {
                                      if (buf[20] == 0x11) {    /* SGMII interface to host */
                                          return MAC_IF_SGMII;
                                      } else {
                                          return MAC_IF_SERDES_1G;
                                      }
                                  }
                              }
                              return MAC_IF_SERDES_1G; /* PHY vendor is unknown */
                          } else {
                              return MAC_IF_SERDES_1G; /* No phy --> SERDES SFP */
                          }
                      } else {
                          if (sfp_i2c_read(0x50, chip_port, SFP_ETHERNET_COMPLIANCE_CODE, &buf[0], 1)) {
                              if ((buf[0] & 0xf) == 0)
                                  return MAC_IF_100FX;
                          }
                      }
                  } else {
              #if USE_HW_TWI
              #if 0 // Ferret, TODO. Missing first parameter
                      i2c_tx(0, &buf[0], 1);
                      i2c_rx(0, &buf[0], 1);
                      delay(MSEC_20);
              #endif // Ferret. TODO.
              #endif // USE_HW_TWI
                  }
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 15  

                  return MAC_IF_SERDES_1G;
              }
              
              #else   // CuSFP_DET = 0
 857   1      {
 858   2          if (sfp_i2c_read(0x50, chip_port, SFP_ETHERNET_COMPLIANCE_CODE, &buf[0], 1)) {
 859   3      
 860   3              if (&buf[0] == 0xff) {
 861   4      #if USE_HW_TWI
 862   4      #if 0 // Ferret, TODO. Missing first parameter
                          /* workaround of h2 twi function */
              
                          uchar value=0;
                          i2c_tx(0, &value, 1);
                          i2c_rx(0, &value, 1);
                          delay(MSEC_20);
              #endif // Ferret. TODO.
 870   4      #endif // USE_HW_TWI
 871   4                  sfp_i2c_read(0x50, chip_port, SFP_ETHERNET_COMPLIANCE_CODE, &buf[0], 1);
 872   4              }
 873   3      
 874   3      #if defined(PHYTSK_DEBUG_ENABLE)
 875   3              print_str("Ethenet Compliance codes(MSA Byte 6):0x");
 876   3              print_hex_b(buf[0]);
 877   3      #endif /* PHYTSK_DEBUG_ENABLE */
 878   3      
 879   3              if ((buf[0] & 0x1) != 0) {
 880   4      #if defined(PHYTSK_DEBUG_ENABLE)
 881   4                  print_str("   1000BASE-SX"); print_cr_lf();
 882   4      #endif /* PHYTSK_DEBUG_ENABLE */
 883   4                  return MAC_IF_SERDES_1G;
 884   4              } else if ((buf[0] & 0x2) != 0) {
 885   4      #if defined(PHYTSK_DEBUG_ENABLE)
 886   4                  print_str("   1000BASE-LX"); print_cr_lf();
 887   4      #endif /* PHYTSK_DEBUG_ENABLE */
 888   4                  return MAC_IF_SERDES_1G;
 889   4              } else if ((buf[0] & 0x4) != 0) {
 890   4      #if defined(PHYTSK_DEBUG_ENABLE)
 891   4                  print_str("   1000BASE-CX"); print_cr_lf();
 892   4      #endif /* PHYTSK_DEBUG_ENABLE */
 893   4                  return MAC_IF_SERDES_1G;
 894   4              } else if ((buf[0] & 0x8) != 0) {
 895   4      #if defined(PHYTSK_DEBUG_ENABLE)
 896   4                  print_str("   1000BASE-T"); print_cr_lf();
 897   4      #endif /* PHYTSK_DEBUG_ENABLE */
 898   4                  return MAC_IF_SERDES_1G;
 899   4              } else if ((buf[0] & 0x10) != 0) {
 900   4      #if defined(PHYTSK_DEBUG_ENABLE)
 901   4                  print_str("   100BASE-LX"); print_cr_lf();
 902   4      #endif /* PHYTSK_DEBUG_ENABLE */
 903   4                  return MAC_IF_100FX;
 904   4              } else if ((buf[0] & 0x20) != 0) {
 905   4      #if defined(PHYTSK_DEBUG_ENABLE)
 906   4                  print_str("   100BASE-FX"); print_cr_lf();
 907   4      #endif /* PHYTSK_DEBUG_ENABLE */
 908   4                  return MAC_IF_100FX;
 909   4              }  else {
 910   4      #if defined(PHYTSK_DEBUG_ENABLE)
 911   4                  print_str("   MAC_IF_SERDES_2_5G(non-standard)");
 912   4      #endif /* PHYTSK_DEBUG_ENABLE */
 913   4                  return MAC_IF_SERDES_2_5G;
 914   4              }
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 16  

 915   3          }
 916   2      
 917   2          return MAC_IF_SERDES_1G; /* Use MAC_IF_SERDES_1G as the default interface when I2C reading failed */
 918   2      }
 919   1      #endif  // CuSFP_DET
 920   1      }
 921          #endif /* TRANSIT_SFP_DETECT */
 922          
 923          /* ************************************************************************ */
 924          static uchar serdes_port_sfp_detect(vtss_cport_no_t chip_port)
 925          /* ------------------------------------------------------------------------ --
 926           * Purpose     : Detect if SFP module present
 927           * Remarks     :
 928           * Restrictions:
 929           * See also    :
 930           * Example     :
 931           ****************************************************************************/
 932          {
 933   1          uchar gpio_value = 0;
 934   1      
 935   1          /* do signal detect */
 936   1          if (phy_map_serdes(chip_port)) {
 937   2      #if defined(LUTON26_L25)
                      ushort reg15g;
              
                      phy_page_gp(SFP_MODULE_GPIO_PORT);
                      reg15g = phy_read(SFP_MODULE_GPIO_PORT, 15);
                      phy_page_std(SFP_MODULE_GPIO_PORT);
                      gpio_value = test_bit_16(1, &reg15g);
              
              #elif defined(LUTON26_L10)
                      switch(chip_port) {
                      case 24:
                          gpio_value = h2_sgpio_read(26, 1);  //sfp0;
                          break;
                      case 25:
                          gpio_value = h2_sgpio_read(27, 1);  //sfp1;
                          break;
                      default:
                          break;
                      }
              
              #elif defined(FERRET_F11) || defined(FERRET_F10P)
                      switch(chip_port) {
                      case SFP1_CHIP_PORT:
                          gpio_value = h2_gpio_read(GPIO_SFP1_PRESENT);  //sfp1;
                          break;
                      case SFP2_CHIP_PORT:
                          gpio_value = h2_gpio_read(GPIO_SFP2_PRESENT);  //sfp2;
                          break;
                      default:
                          break;
                      }
              
              #elif defined(FERRET_F5)
 970   2              switch(chip_port) {
 971   3              case SFP2_CHIP_PORT:
 972   3                  gpio_value = h2_gpio_read(GPIO_SFP2_PRESENT);  //sfp2;
 973   3                  break;
 974   3              default:
 975   3                  break;
 976   3              }
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 17  

 977   2      #endif
 978   2          }
 979   1      
 980   1          return gpio_value ? FALSE : TRUE; // 0: not present, 1: present
 981   1      }
 982          
 983          /* ************************************************************************ */
 984          static void handle_serdes(vtss_cport_no_t chip_port)
 985          /* ------------------------------------------------------------------------ --
 986           * Purpose     : State machine for Serdes port. Monitor and set up switch port.
 987           * Remarks     :
 988           * Restrictions:
 989           * See also    :
 990           * Example     :
 991           ****************************************************************************/
 992          {
 993   1          uchar mac_if, lm = LINK_MODE_DOWN, sfp_existed, speed;
 994   1      
 995   1          switch (port_state_machine[chip_port]) {
 996   2          case PORT_DISABLED: {
 997   3              break;
 998   3          }
 999   2      
1000   2          case SERDES_SIG_SET_UP_MODE: {
1001   3              // Do nothing here, pass to 'SERDES_SET_UP_MODE' state
1002   3              port_state_machine[chip_port] = SERDES_SET_UP_MODE;  // Change state
1003   3              break;
1004   3          }
1005   2      
1006   2          case SERDES_SET_UP_MODE: {
1007   3              /* Detect if SFP module present or not.
1008   3               * Notice that the PCS clock need to be enabled first.
1009   3               */
1010   3              _sfp_tx_disable_set(chip_port, TRUE);  // Disable SFP TX
1011   3              h2_pcs1g_clock_set(chip_port, TRUE);    // Enable PCS clock
1012   3      #ifdef SGMII_SERDES_FORCE_1G_DEBUG_ENABLE
                      sfp_existed = 0; //No need to detect speed since 1G forced
              #else
1015   3              sfp_existed = serdes_port_sfp_detect(chip_port);
1016   3      #endif
1017   3      #if 0 // To test serdes_port_sfp_detect function and i2c function
              {
                      static uchar debug_sfp_existed[2] = {0, 0};
                      if (chip_port == SFP1_CHIP_PORT || chip_port == SFP2_CHIP_PORT) {
                          if (debug_sfp_existed[chip_port == SFP1_CHIP_PORT ? 0 : 1] != sfp_existed) {
                              debug_sfp_existed[chip_port == SFP1_CHIP_PORT ? 0 : 1] = sfp_existed;
                              print_str("chip_port=");
                              print_dec(chip_port);
                              print_str(", sfp_existed=");
                              print_dec(sfp_existed);
                              print_cr_lf();
              
                              if (sfp_existed) {
                                  delay_1(250); // BZ#20186, delay for 250 mseconds
                                  mac_if = sfp_detect(chip_port);
                              } else {
                                  mac_if = MAC_IF_UNKNOWN;
                              }
                              print_str(", mac_if=");
                              print_dec(mac_if);
                              print_cr_lf();
                          }
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 18  

                      }
              }
              #endif // #if 0
1042   3      
1043   3      #if TRANSIT_SFP_DETECT
1044   3              // Read SFP EEPROM information(MSA) via I2C bus
1045   3              if (sfp_existed) {
1046   4                  /* BZ#20186, delay for 250 mseconds for some SFP modules needing
1047   4                      some time to get i2c interface ready */
1048   4                  delay_1(250);
1049   4                  mac_if = sfp_detect(chip_port);
1050   4              } else {
1051   4                  phy_map_serdes_if_restore(chip_port);
1052   4                  return; // Keep the original state
1053   4              }
1054   3      
1055   3              if (mac_if != phy_map_miim_no(chip_port)) {
1056   4                  phy_map_serdes_if_update(chip_port, mac_if);
1057   4                  mac_if_changed[chip_port] = 1;
1058   4              }
1059   3      #else
                      mac_if = phy_map_miim_no(chip_port);
              #endif // TRANSIT_SFP_DETECT
1062   3      
1063   3              if (mac_if_changed[chip_port]) {
1064   4                  vtss_serdes_mode_t media_if;
1065   4      #if defined(LUTON26_L25) || defined(LUTON26_L10) || defined(FERRET_F11) || defined(FERRET_F10P) || defined
             -(FERRET_F5) || defined(FERRET_F4P)
1066   4                  ulong sd1g_addr = 0xFF; // None SERDES1G
1067   4                  ulong sd6g_addr = 0xFF; // None SERDES6G
1068   4      #endif
1069   4                  mac_if_changed[chip_port] = 0;
1070   4      
1071   4      #if defined(LUTON26_L25)
                          sd1g_addr = 0x1;
              #elif defined(LUTON26_L10)
                          switch(chip_port) {
                          case 24:
                              sd1g_addr = 0x2;
                              break;
                          case 25:
                              sd1g_addr = 0x1;
                              break;
                          }
              
              #elif defined(FERRET_F11)
                          switch(chip_port) {
                          case SFP1_CHIP_PORT:
                              sd6g_addr = 0x2; // DEV[8] is mapping to SERDES6G_1
                              break;
                          case SFP2_CHIP_PORT:
                              sd6g_addr = 0x4; // DEV[10] is mapping to SERDES6G_2
                              break;
                          }
              
              #elif defined(FERRET_F10P)
                          switch(chip_port) {
                          case SFP1_CHIP_PORT:
                              sd6g_addr = 0x2; // DEV[8] is mapping to SERDES6G_1
                              break;
                          case SFP2_CHIP_PORT:
                              sd1g_addr = 0x10; // DEV[9] is mapping to SERDES1G_4
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 19  

                              break;
                          }
              
              
              #elif defined(FERRET_F5)
1105   4                  switch(chip_port) {
1106   5                  case SFP2_CHIP_PORT:
1107   5                      sd6g_addr = 0x4; // DEV[10] is mapping to SERDES6G_2
1108   5                      break;
1109   5                  }
1110   4      #endif // LUTON26_L25
1111   4      
1112   4                  switch(mac_if) {
1113   5                  case MAC_IF_SERDES_2_5G:
1114   5                      media_if = VTSS_SERDES_MODE_2G5;
1115   5                      break;
1116   5                  case MAC_IF_SERDES_1G:
1117   5                      media_if = VTSS_SERDES_MODE_1000BaseX;
1118   5                      break;
1119   5                  case MAC_IF_SGMII:
1120   5                      media_if = VTSS_SERDES_MODE_SGMII;
1121   5                      break;
1122   5                  case MAC_IF_100FX:
1123   5                      media_if = VTSS_SERDES_MODE_100FX;
1124   5                      break;
1125   5                  default:
1126   5                      media_if = VTSS_SERDES_MODE_1000BaseX;
1127   5                  }
1128   4      
1129   4                  if (sd6g_addr != 0xFF) { // SERDES6G_X
1130   5                      h2_sd6g_cfg_change(media_if, sd6g_addr);
1131   5                  }
1132   4                  if (sd1g_addr != 0xFF) { // SERDES1G_X
1133   5                      h2_sd1g_cfg(media_if, sd1g_addr);
1134   5                  }
1135   4      
1136   4                  /* Set PCS1G configuration */
1137   4                  if (mac_if == MAC_IF_SERDES_1G || mac_if == MAC_IF_SERDES_2_5G || mac_if == MAC_IF_SGMII || ma
             -c_if == MAC_IF_100FX) {
1138   5                      h2_pcs1g_setup(chip_port, mac_if);
1139   5                  }
1140   4      
1141   4                  if (mac_if == MAC_IF_SERDES_1G || mac_if == MAC_IF_SERDES_2_5G || mac_if == MAC_IF_SGMII || ma
             -c_if == MAC_IF_100FX) {
1142   5                      h2_pcs1g_clause_37_control_set(chip_port, phy_flowcontrol_get(chip_port));
1143   5                  } else {
1144   5                      /* 100 Full mode and Auto SFP mode, do nothing */
1145   5                  }
1146   4      
1147   4                  h2_setup_port(chip_port, LINK_MODE_DOWN);
1148   4              }
1149   3      
1150   3              port_state_machine[chip_port] = SERDES_WAITING_FOR_LINK; // Change state
1151   3      
1152   3              break;
1153   3          }
1154   2      
1155   2          case SERDES_WAITING_FOR_LINK: {
1156   3              if (poll_phy_flag) {
1157   4      #if defined(FERRET_SFP_LM_WORKAROUND)
1158   4                   uchar lm_same_cnt = 0, lm_retry_cnt = 0;
1159   4      #endif // FERRET_SFP_LM_WORKAROUND
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 20  

1160   4      
1161   4                  _sfp_tx_disable_set(chip_port, FALSE);  // Enable SFP TX
1162   4      #if TRANSIT_SFP_DETECT
1163   4                  sfp_existed = serdes_port_sfp_detect(chip_port);  // Detect if SFP module present or not.
1164   4                  if (!sfp_existed) {
1165   5                      phy_map_serdes_if_restore(chip_port);
1166   5      
1167   5      #if defined(PHYTSK_DEBUG_ENABLE)
1168   5                      print_str("SFP module is unplugged on uport");
1169   5                      print_dec_8_right_2(cport2uport(chip_port));
1170   5                      print_cr_lf();
1171   5      #endif /* PHYTSK_DEBUG_ENABLE */
1172   5      
1173   5                      port_state_machine[chip_port] = SERDES_SET_UP_MODE;  // Change state
1174   5                      break;
1175   5                  }
1176   4      #endif // TRANSIT_SFP_DETECT
1177   4      
1178   4                  mac_if = phy_map_miim_no(chip_port);
1179   4                  lm = serdes_link_mode_get(chip_port);
1180   4                  speed = lm & LINK_MODE_SPEED_MASK;
1181   4      
1182   4                  if (lm != LINK_MODE_DOWN) {  /* Link up */
1183   5                      if (mac_if == MAC_IF_SGMII || mac_if == MAC_IF_SERDES_2_5G) {
1184   6                          ulong tgt = VTSS_TO_DEV(chip_port);
1185   6      
1186   6      #if defined(VTSS_ARCH_LUTON26)
                                  if ((lm & LINK_MODE_SPEED_AND_FDX_MASK) == LINK_MODE_FDX_1000) {
                                      H2_WRITE_MASKED(VTSS_DEV_CMN_MAC_CFG_STATUS_MAC_MODE_CFG(tgt), 0x00000011, 0x00000
             -011);
                                  } else {
                                      if (lm & LINK_MODE_FDX_MASK) {
                                          H2_WRITE_MASKED(VTSS_DEV_CMN_MAC_CFG_STATUS_MAC_MODE_CFG(tgt), 0x00000001, 0x0
             -0000011);
                                      } else {
                                          H2_WRITE_MASKED(VTSS_DEV_CMN_MAC_CFG_STATUS_MAC_MODE_CFG(tgt), 0x00000000, 0x0
             -0000011);
                                      }
                                  }
              
              #elif defined(FERRET_F11) || defined(FERRET_F10P) || defined(FERRET_F5) || defined(FERRET_F4P)
1198   6                          BOOL giga_mode_ena = (lm & LINK_MODE_SPEED_MASK) >= LINK_MODE_SPEED_1000 ? 1 : 0;
1199   6                          H2_WRITE_MASKED(VTSS_DEV_MAC_CFG_STATUS_MAC_MODE_CFG(tgt),
1203   6                                          VTSS_F_DEV_MAC_CFG_STATUS_MAC_MODE_CFG_GIGA_MODE_ENA(giga_mode_ena) |
1203   6                                          VTSS_F_DEV_MAC_CFG_STATUS_MAC_MODE_CFG_FDX_ENA(lm & LINK_MODE_FDX_MASK
             - ? 1 : 0),
1203   6                                          VTSS_M_DEV_MAC_CFG_STATUS_MAC_MODE_CFG_GIGA_MODE_ENA |
1203   6                                          VTSS_M_DEV_MAC_CFG_STATUS_MAC_MODE_CFG_FDX_ENA);
1204   6      #endif
1205   6                      }
1206   5      
1207   5                      h2_setup_port(chip_port, lm);
1208   5      
1209   5      #if defined(FERRET_SFP_LM_WORKAROUND)
1210   5                      do {
1211   6                          delay_1(2);
1212   6                          if (lm == serdes_link_mode_get(chip_port)) {
1213   7                              lm_same_cnt++;
1214   7                          }
1215   6                      } while (lm_retry_cnt++ < 2);
1216   5      
1217   5                      if (lm_same_cnt == lm_retry_cnt)
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 21  

1218   5      #endif // FERRET_SFP_LM_WORKAROUND
1219   5                      {
1220   6      #if defined(PHYTSK_DEBUG_ENABLE)
1221   6                          print_str("SFP Link-Up on uport");
1222   6                          print_dec_8_right_2(cport2uport(chip_port));
1223   6                          if (speed == LINK_MODE_SPEED_10) {
1224   7                              print_str(" - 10M");
1225   7                          } else if (speed == LINK_MODE_SPEED_100) {
1226   7                              print_str(" - 100M");
1227   7                          } else if (speed == LINK_MODE_SPEED_1000) {
1228   7                              print_str(" - 1G");
1229   7                          } else if (speed == LINK_MODE_SPEED_2500) {
1230   7                              print_str(" - 2.5G");
1231   7                          } else {
1232   7                              print_str("Unknown speed");
1233   7                          }
1234   6                          if (lm & LINK_MODE_FDX_MASK) {
1235   7                              println_str("FDX");
1236   7                          } else {
1237   7                              println_str("HDX");
1238   7                          }
1239   6      #endif /* PHYTSK_DEBUG_ENABLE */
1240   6                          do_link_up(chip_port, lm);
1241   6                          port_state_machine[chip_port] = SERDES_LINK_UP;  // Change state
1242   6                      }
1243   5                  }
1244   4      
1245   4              }
1246   3              break;
1247   3          }
1248   2      
1249   2          case SERDES_LINK_UP: {
1250   3              if (poll_phy_flag) {
1251   4      #if TRANSIT_SFP_DETECT
1252   4                  sfp_existed = serdes_port_sfp_detect(chip_port);  // Detect if SFP module present or not.
1253   4                  if (!sfp_existed) {
1254   5                      phy_map_serdes_if_restore(chip_port);
1255   5                      do_link_down(chip_port);
1256   5      
1257   5      #if defined(PHYTSK_DEBUG_ENABLE)
1258   5                      print_str("SFP module is unplugged on uport");
1259   5                      print_dec_8_right_2(cport2uport(chip_port));
1260   5                      print_cr_lf();
1261   5      #endif /* PHYTSK_DEBUG_ENABLE */
1262   5      
1263   5                      port_state_machine[chip_port] = SERDES_SET_UP_MODE;  // Change state
1264   5                      break;
1265   5                  }
1266   4      #endif // TRANSIT_SFP_DETECT
1267   4      
1268   4                  /* Check if link has been down or link mode is changed */
1269   4                  lm = serdes_link_mode_get(chip_port);
1270   4                  if (lm == serdes_link_mode_get(chip_port) &&
1271   4                      (lm == LINK_MODE_DOWN || lm != port_lm[chip_port])) {
1272   5      #if defined(PHYTSK_DEBUG_ENABLE)
1273   5                      print_str("SFP Link-Down on uport");
1274   5                      print_dec_8_right_2(cport2uport(chip_port));
1275   5                      print_cr_lf();
1276   5      #endif /* PHYTSK_DEBUG_ENABLE */
1277   5      
1278   5                      do_link_down(chip_port);
1279   5                      port_state_machine[chip_port] = SERDES_WAITING_FOR_LINK; // Change state
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 22  

1280   5                  }
1281   4              }
1282   3              break;
1283   3          }
1284   2      
1285   2          default:
1286   2              break;
1287   2          }
1288   1      }
1289          #endif /* MAC_TO_MEDIA */
1290          
1291          
1292          /****************************************************************************
1293           *
1294           * Public functions
1295           *
1296           ****************************************************************************/
1297          
1298          
1299          void phy_timer_10 (void)
1300          {
1301   1          static uchar poll_phy_timer = 0;
1302   1      
1303   1          if (++poll_phy_timer >= 10) {
1304   2              poll_phy_timer = 0;
1305   2              poll_phy_flag = 1;
1306   2          }
1307   1      
1308   1      }
1309          
1310          
1311          uchar phy_check_all (void)
1312          {
1313   1          vtss_iport_no_t iport_idx;
1314   1          vtss_cport_no_t chip_port;
1315   1          uchar           error = 0;
1316   1      
1317   1          for (iport_idx = MIN_PORT; iport_idx < MAX_PORT; iport_idx++) {
1318   2              chip_port = iport2cport(iport_idx);
1319   2              if (phy_map(chip_port)) {
1320   3      #if PHY_ID_CHECK
                          if (phy_read(chip_port, 2) != PHY_OUI_MSB) {
                              error = 1;
                              break;
                          }
              #endif
1326   3              }
1327   2          }
1328   1      
1329   1          return error;
1330   1      }
1331          
1332          
1333          #if LOOPBACK_TEST
              void phy_restart (vtss_cport_no_t chip_port)
              {
                  if (phy_map(chip_port)) {
                      phy_reset(chip_port);
                      port_state_machine[chip_port] = PHY_SET_UP_SPEED_MODE;  // Change state
                  }
              #if MAC_TO_MEDIA
                  else if (phy_map_serdes(chip_port)) {
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 23  

                      port_state_machine[chip_port] = SERDES_SET_UP_MODE;   // Change state
                  }
              #endif
                  do_link_down(chip_port);
              }
              #endif /* LOOPBACK_TEST */
1348          
1349          
1350          uchar phy_tsk_init (void)
1351          {
1352   1          vtss_iport_no_t iport_idx;
1353   1          vtss_cport_no_t chip_port;
1354   1      
1355   1          // Local database initialization
1356   1          linkup_cport_mask = 0;
1357   1      
1358   1          for (iport_idx = MIN_PORT; iport_idx < MAX_PORT; iport_idx++) {
1359   2              chip_port = iport2cport(iport_idx);
1360   2              port_lm[chip_port] = LINK_MODE_DOWN;
1361   2              port_state_machine[chip_port] = phy_init_state(chip_port);   // State initialization
1362   2      
1363   2      #if defined(UNMANAGED_FLOW_CTRL_IF)
1364   2              port_fc_config[chip_port] = TRANSIT_FLOW_CTRL_DEFAULT;
1365   2      #endif // UNMANAGED_FLOW_CTRL_IF
1366   2      
1367   2              if (phy_map(chip_port)) {
1368   3                  mac_if_changed[chip_port] = 0;
1369   3      #if MAC_TO_MEDIA
1370   3              } else if (phy_map_serdes(chip_port)) {
1371   3                  mac_if_changed[chip_port] = 1;
1372   3      #endif
1373   3              }
1374   2      
1375   2          }
1376   1      
1377   1          phy_init(); // Phy Init must come after the h2_init_port, because the port clocks must be enabled.
1378   1          sfp_init();
1379   1      
1380   1          if (phy_check_all()) {
1381   2              return 1; // Failed
1382   2          }
1383   1      
1384   1          return 0; // OK
1385   1      }
1386          
1387          #if defined(UNMANAGED_FLOW_CTRL_IF)
1388          void   phy_state_to_setup (vtss_cport_no_t chip_port)
1389          {
1390   1          // Move port state back to either PHY_SET_UP_SPEED_MODE or SERDES_SET_UP_MODE
1391   1          if (phy_map(chip_port)) {
1392   2              if (port_state_machine[chip_port] == PHY_LINK_UP) {
1393   3                  do_link_down(chip_port);
1394   3      
1395   3                  phy_write(chip_port, 31, 0x2a30);  // switch to test-register page
1396   3                  phy_write_masked(chip_port, 5, 0x0, 0x6);    // write[2:1]={00}:Unforce polarity
1397   3                  phy_write(chip_port, 31, 0x0); // switch to std page
1398   3      
1399   3                  /* enable polarity detection */
1400   3                  phy_write_masked(chip_port, 0x12, 0x0000, 0x0010);
1401   3              }
1402   2              port_state_machine[chip_port] = PHY_SET_UP_SPEED_MODE;
1403   2          }
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 24  

1404   1      #if MAC_TO_MEDIA
1405   1           else if (phy_map_serdes(chip_port)) {
1406   2              port_state_machine[chip_port] = SERDES_SET_UP_MODE;
1407   2          }
1408   1      #endif
1409   1      }
1410          
1411          void phy_flowcontrol_set(vtss_cport_no_t chip_port, BOOL mode_enabled)
1412          {
1413   1          port_fc_config[chip_port] = mode_enabled;
1414   1      }
1415          #endif // UNMANAGED_FLOW_CTRL_IF
1416          
1417          void phy_tsk (void)
1418          {
1419   1          vtss_iport_no_t iport_idx;
1420   1          vtss_cport_no_t chip_port;
1421   1      
1422   1          for (iport_idx = MIN_PORT; iport_idx < MAX_PORT; iport_idx++) {
1423   2              chip_port = iport2cport(iport_idx);
1424   2              if (phy_map(chip_port)) {
1425   3                  handle_phy(chip_port);
1426   3              }
1427   2      #if MAC_TO_MEDIA
1428   2              else if (phy_map_serdes(chip_port)) {
1429   3                  handle_serdes(chip_port);
1430   3              }
1431   2      #endif
1432   2          }
1433   1      
1434   1          poll_phy_flag = 0;
1435   1      }
1436          
1437          uchar port_link_mode_get(vtss_cport_no_t chip_port)
1438          {
1439   1          return port_lm[chip_port];
1440   1      }
1441          
1442          BOOL is_port_link(vtss_cport_no_t chip_port)
1443          {
1444   1          if (TEST_PORT_BIT_MASK(chip_port, &linkup_cport_mask)) {
1445   2              return TRUE;
1446   2          }
1447   1      
1448   1          return FALSE;
1449   1      }
1450          
1451          #if TRANSIT_LAG || TRANSIT_LOOPDETECT
              port_bit_mask_t linkup_cport_mask_get(void)
              {
                  return linkup_cport_mask;
              }
              #endif
1457          
1458          #if TRANSIT_VERIPHY
              
              /****************************************************************************
               *
               *
               * VeriPHY
               *
               *
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 25  

               ****************************************************************************/
              
              /**
               * Run veriphy on all ports.
               *
               * @todo Run only on PHY ports.
               */
              void phy_veriphy_all (void)
              {
                  uchar                   j;
                  uchar                   errors;
                  /* veriphy_parms_t xdata veriphy_parms [NO_OF_CHIP_PORTS]; */
                  veriphy_parms_t xdata   *veriphy_parms = (veriphy_parms_t *) rx_packet;
                  BOOL                    all_done = FALSE;
                  BOOL                    done;
                  ushort                  timeout = 1500;
                  port_bit_mask_t         iport_mask;
                  vtss_iport_no_t         iport_idx;
                  vtss_cport_no_t         chip_port;
              
                  // Fill iport_mask
                  for (iport_idx = MIN_PORT; iport_idx < MAX_PORT; iport_idx++) {
                      WRITE_PORT_BIT_MASK(iport, 1, &iport_mask);
                  }
              
                  // Start VeriPhy
                  for (iport_idx = MIN_PORT; iport_idx < MAX_PORT; iport_idx++) {
                      chip_port = iport2cport(iport_idx);
                      if (TEST_PORT_BIT_MASK(iport_idx, &iport_mask) && phy_map(chip_port)) {
                          /* Read PHY id to determine action */
                          veriphy_start(chip_port); // Starting veriphy for selected port(s)
                      }
                  }
              
                  // Pulling Verphy until Veriphy is done
                  for (iport_idx = MIN_PORT; iport_idx < MAX_PORT; iport_idx++) {
                      chip_port = iport2cport(iport_idx);
                      /* Different procedure ???
                        The API in clihnd.c/cmd_run_veriphy() do the following
                        phy_page_std(chip_port);
                      */
                      if (TEST_PORT_BIT_MASK(iport_idx, &iport_mask) && phy_map(chip_port)) {
                          done = FALSE;
                          while (!done) {
                              veriphy_run(chip_port, (veriphy_parms + chip_port), &done);
                          }
                      }
                  }
              
                  // Check if any error occurred
                  errors = 0;
                  for (iport_idx = MIN_PORT; iport_idx < MAX_PORT; iport_idx++) {
                      chip_port = iport2cport(iport_idx);
                      if (TEST_PORT_BIT_MASK(iport_idx, &iport_mask) && phy_map(chip_port)) {
                          /* Status is valid */
                          if (!(veriphy_parms + chip_port)->flags) {
                              errors = 1;
                          }
                          /* Status for each pair */
                          for (j = 0; j < 4; j++) {
                              if ((veriphy_parms + chip_port)->stat[j]) {
                                  /* Set Error Leds */
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 26  

                                  errors = 1;
                              }
                          }
              #if FRONT_LED_PRESENT
                          if (errors) {
                              led_port_event_set(iport_idx, VTSS_LED_EVENT_VERIPHY_ERR, VTSS_LED_MODE_BLINK_YELLOW);
                          }
              #endif // FRONT_LED_PRESENT
                      }
                  }
              
              #if FRONT_LED_PRESENT
                  if (errors) {
                      delay_1(3000); // Show error state for 3 seconds
                      for (iport_idx = MIN_PORT; iport_idx < MAX_PORT; iport_idx++) {
                          chip_port = iport2cport(port_no);
              
                          if (TEST_PORT_BIT_MASK(iport_idx, &iport_mask) && phy_map(chip_port)) {
                              led_port_event_set(iport_idx, VTSS_LED_EVENT_VERIPHY_ERR, VTSS_LED_MODE_NORMAL);
                          }
                      }
                  }
              #endif // FRONT_LED_PRESENT
              }
              #endif /* TRANSIT_VERIPHY */
1553          
1554          #if TRANSIT_ACTIPHY
              /* Set ActiPHY mode operation */
              void phy_actiphy_set(BOOL mode_enabled)
              {
                  vtss_iport_no_t iport_idx;
                  vtss_cport_no_t chip_port;
              
                  for (iport_idx = MIN_PORT; iport_idx < MAX_PORT; iport_idx++) {
                      chip_port = iport2cport(iport_idx);
                      if (phy_map(chip_port)) {
                          phy_page_tp(chip_port);
                          phy_write_masked(chip_port, 12, 0x0000, 0xfc00);
                          phy_write_masked(chip_port, 24, 0x2000, 0x2000);
                          phy_page_std(chip_port);
                          phy_write_masked(chip_port, 28, mode_enabled ? 0x0040 : 0x0000, 0x0040);
                          delay_1(1);
                      }
                  }
              }
              #endif /* TRANSIT_ACTIPHY */
1574          
1575          
1576          #if TRANSIT_FAN_CONTROL || TRANSIT_THERMAL
              ushort phy_get_sys_temp (void)
              {
                  ushort temp_0 = 0, temp_1 = 0;
                  temp_0 = phy_read_temp_reg(0);
              #if defined(LUTON26_L25)
                  temp_1 = phy_read_temp_reg(12);
              #else
                  temp_1 = 0;
              #endif
              
                  return MAX(temp_1, temp_0);
              }
              #endif
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 27  

1590          
1591          
1592          #if TRANSIT_THERMAL
              void phy_handle_temperature_protect()
              {
                  ushort temperatue, temp;
                  uchar  port_ext;
                  uchar  port_no;
                  uchar  temp_id;
              
                  uchar enable;
              
                  const uchar code protect_port[] = {3, 7, 13, 19, 23, 26};
                  const uchar code protect_temp[] = {0, 1, 2,  3,  4,  5}; /* Threshhold is 122C ~ 128C*/
              
                  enable = 1;
              
                  temperatue = phy_get_sys_temp();
              
                  temp_id = 0xff;
                  if (temperatue >= max_protect_temp) {  /* Temp. over threshold */
                      start_thermal_protect_timer = TRUE;  /* Start the protectioin timer */
                      thermal_protect_cnt = MAX_THERMAL_PROT_TIME; /* Refresh the timer value to default value 10 sec */
              
                      temp = temperatue - max_protect_temp; /* Find the power down ports */
                      for (temp_id = 0; temp_id < ARRAY_LENGTH(protect_temp) - 1; temp_id++) {
                          if (temp >= protect_temp[temp_id] && temp < protect_temp[temp_id + 1])
                              break;
                      }
              
              #if defined(PHYTSK_DEBUG_ENABLE)
                      print_str("temp. is ");
                      print_dec(temperatue);
                      print_cr_lf();
              #endif /* PHYTSK_DEBUG_ENABLE */
              
              #if 0
                      print_str("cur temp. diff = ");
                      print_dec(temp);
                      print_ch('(');
                      print_dec(protect_temp[temp_id]);
                      print_str("), power down ports = ");
                      print_dec(protect_port[temp_id]);
                      print_cr_lf();
              #endif
                  }
              
                  if (temp_id != 0xff && temp_id < ARRAY_LENGTH(protect_temp)) {
                      for (port_ext = 1; port_ext <= NO_OF_BOARD_PORTS; port_ext++) {
                          uchar half = protect_port[temp_id] / 2;
                          uchar half_port = (MAX_PORT + MIN_PORT) / 2;
                          port_no = uport2cport(port_ext);
                          if (phy_map(port_no)
              #if MAC_TO_MEDIA
                                  || phy_map_serdes(port_no)
              #endif
                            ) {
                              if (port_ext < half_port) { /* power down ports */
                                  if (port_ext <= half) {
                                      if (!TEST_PORT_BIT_MASK(port_no, &led_err_stat)) {
                                          if (enable) {
                                              phy_set_enable(port_no, FALSE);
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 28  

                                          }
                                          WRITE_PORT_BIT_MASK(port_no, 1, &led_err_stat);
              #if FRONT_LED_PRESENT
                                          led_state_set(port_ext, VTSS_LED_EVENT_PHY_OVERHEAT, VTSS_LED_MODE_BLINK_YELLO
             -W);
              #endif
                                      }
                                  }
                              } else {
                                  if (port_ext < (half_port + (protect_port[temp_id] - half))) {
                                      if (!TEST_PORT_BIT_MASK(port_no, &led_err_stat)) {
                                          if (enable) {
                                              phy_set_enable(port_no, FALSE);
                                          }
                                          WRITE_PORT_BIT_MASK(port_no, 1, &led_err_stat);
              #if FRONT_LED_PRESENT
                                          led_state_set(port_ext, VTSS_LED_EVENT_PHY_OVERHEAT, VTSS_LED_MODE_BLINK_YELLO
             -W);
              #endif
                                      }
                                  }
                              }
                          }
                      }
                  }
              
                  if (!start_thermal_protect_timer) { /* timer is stopped. */
                      for (port_ext = 1; port_ext <= NO_OF_BOARD_PORTS; port_ext++) {
                          port_no = uport2cport(port_ext);
                          if (phy_map(port_no)
              #if MAC_TO_MEDIA
                                  || phy_map_serdes(port_no)
              #endif
                            ) {
                              if (TEST_PORT_BIT_MASK(port_no, &led_err_stat)) { /* power on the ports */
                                  if (enable) {
                                      phy_set_enable(port_no, TRUE);
                                  }
                                  WRITE_PORT_BIT_MASK(port_no, 0, &led_err_stat);
              #if FRONT_LED_PRESENT
                                  led_state_set(port_ext, VTSS_LED_EVENT_PHY_OVERHEAT, VTSS_LED_MODE_NORMAL);
              #endif
                              }
                          }
                      }
                  }
              
              #if 0
                  if (led_err_stat) {
                      print_str("over heat led stat ");
                      print_hex_prefix();
                      print_hex_dw(led_err_stat);
                      print_cr_lf();
                  }
              #endif
              }
              
              
              void phy_temperature_timer_1sec (void)
              {
                  if (start_thermal_protect_timer)
                  {
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 29  

                      thermal_protect_cnt--;
              
                      if (thermal_protect_cnt == 0)
                      {
                          start_thermal_protect_timer = FALSE;
                      }
                  }
              }
              
              
              #endif /* TRANSIT_THERMAL */
1723          
1724          
1725          #if TRANSIT_THERMAL
              void phy_set_enable (vtss_cport_no_t chip_port, uchar status)
              {
                  if (phy_map(chip_port) && TEST_PORT_BIT_MASK(chip_port, &phy_enabled) != status) {
                      WRITE_PORT_BIT_MASK(chip_port, status, &phy_enabled);
              
                      if (status) {
                          phy_write_masked(chip_port, 0, 0, 0x800);
                          phy_restart(chip_port);
                      } else {
              #if TRANSIT_LLDP
                          /* make sure to transmit shutdown LLDPDU before link goes away */
                          lldp_pre_port_disabled(cport2uport(chip_port));
              #endif /* TRANSIT_LLDP */
                          do_link_down(chip_port);
                          if (phy_map(chip_port)) {
                              phy_power_down(chip_port);
                          }
              #if  MAC_TO_MEDIA
              #if defined(VTSS_ARCH_LUTON26)
                          else if (phy_map_serdes(chip_port)) {
                              uchar mac_if = phy_map_miim_no(chip_port);
                              if (mac_if == MAC_IF_SERDES_1G || mac_if == MAC_IF_SGMII) {
                                  h2_pcs1g_clock_set(chip_port, FALSE); // Disable PCS clock
                              }
                          }
              #elif defined(FERRET_F11) || defined(FERRET_F10P) || defined(FERRET_F5) || defined(FERRET_F4P)
                  // Ferret, TODO. Not implement yet
              #endif
              #endif // MAC_TO_MEDIA
              
                          port_state_machine[chip_port] = PORT_DISABLED; // Change state
                      }
                  }
              }
              #endif
1761          
1762          
1763          /****************************************************************************/
1764          /*                                                                          */
1765          /*  End of file.                                                            */
1766          /*                                                                          */
1767          /****************************************************************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3182    ----
   CONSTANT SIZE    =    414    ----
   XDATA SIZE       =     53      81
C51 COMPILER V9.60.0.0   PHYTSK                                                            11/30/2021 16:22:23 PAGE 30  

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
